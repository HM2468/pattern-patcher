-# frozen_string_literal: true
-# app/views/repository_files/_file_list.html.haml

- if @repositories.empty?
  %div{ class: "p-6 text-gray-700" } No repositories found.
- elsif @current_repo.nil?
  %div{ class: "p-6 text-gray-700" } Please select a repository.
- elsif @repository_files.empty?
  %div{ class: "p-6 text-gray-700" } Please import files or check whether the repository is empty.
- else
  -# pass two confirm messages to JS via data- attrs
  %div#repo_files_panel{
    class: "flex-1 overflow-auto rounded-2xl bg-white shadow-sm",
    data: {
      repo_id: @current_repo.id,
      scan_hint_empty: @scan_all_hint,    # file_ids empty => use this
      scan_hint_all: @scan_hint_message   # file_ids non-empty => use this
    }
  }
    %table#repo_files_table{ class: "w-full text-sm table-fixed" }
      %thead{ class: "bg-indigo-100 text-gray-600 sticky top-0 z-10" }
        %tr
          %th{ class: "px-4 py-3 font-semibold" }
            %div#repo_files_toolbar{ class: "flex items-center gap-3" }
              %div{ class: "flex items-start gap-2 shrink-0" }
                %input#check_all{ type: "checkbox", class: "mt-1 scale-150" }

                %div{ class: "flex flex-col items-start text-left leading-tight" }
                  %span{ class: "text-sm" } Select All
                  %div#bulk_hint{ class: "text-xs text-gray-500" }
                    200/page

              %div{ class: "flex-1 px-2" }
                %input#path_filter_input{
                  type: "text",
                  value: @path_filter,
                  placeholder: "prefix matching filter (live search)",
                  class: "w-full text-sm rounded px-3 py-2 bg-white",
                  autocomplete: "off"
                }

              %div{ class: "ml-auto flex items-center gap-2 shrink-0" }
                -# Scan is ALWAYS enabled (even when nothing selected)
                %button#bulk_scan{ type: "button", class: "button-primary" } Scan
                -# Delete is disabled until something selected
                %button#bulk_delete{ type: "button", class: "button-danger" } Delete

      %tbody#repo_files_tbody{ class: "divide-y divide-gray-300" }
        - @repository_files.each do |f|
          %tr{ class: "hover:bg-indigo-50/60 transition", data: { file_id: f.id } }
            %td{ class: "px-4 py-3" }
              %div{ class: "flex items-start gap-3" }
                %input{
                  id: "file_check_#{f.id}",
                  type: "checkbox",
                  value: f.id,
                  data: { file_check: "1" },
                  class: "mt-1 scale-150"
                }
                %label{ for: "file_check_#{f.id}", class: "flex-1 min-w-0 cursor-pointer" }
                  %div{ class: "truncate font-mono text-sm text-gray-900", title: f.path }
                    = f.path

  -# ✅ Scan form (hidden). JS fills file_ids[] then clicks hidden submit button (with PopConfirmLog)
  %div{ class: "hidden" }
    = form_with url: scan_runs_path, method: :post, local: true,
      html: { id: "bulk_scan_form", class: "inline-flex" } do
      = hidden_field_tag :repository_id, @current_repo.id, id: "bulk_scan_repository_id"
      %div#bulk_scan_file_ids
      %button#bulk_scan_trigger{
        type: "submit",
        onclick: "return window.PopConfirmLog.open(event, this)",
        data: {
          confirm_title: "Scan files",
          confirm_message_html: @scan_hint_message, # JS will override before click
          confirm_confirm_label: "Scan",
          confirm_cancel_label: "Cancel"
        },
        class: "button-primary"
      } Scan

  -# ✅ Delete form (hidden). JS fills file_ids[] then clicks hidden submit button (with PopConfirmLog)
  %div{ class: "hidden" }
    = form_with url: bulk_delete_repository_files_path, method: :post, local: true,
      html: { id: "bulk_delete_form", class: "inline-flex" } do
      = hidden_field_tag :repository_id, @current_repo.id
      %div#bulk_delete_file_ids
      %button#bulk_delete_trigger{
        type: "submit",
        onclick: "return window.PopConfirmLog.open(event, this)",
        data: {
          confirm_title: "Delete files",
          confirm_message: "Delete selected files? This cannot be undone.",
          confirm_confirm_label: "Delete",
          confirm_cancel_label: "Cancel"
        },
        class: "button-danger"
      } Delete

%div#repo_files_pagination{ class: "bottom-pagination" }
  = render "shared/pagination",
    collection: @repository_files,
    options: { repository_id: @current_repo&.id, path_filter: @path_filter }.compact

:javascript
  (function() {
    function initRepoFilesPage() {
      const panel = document.getElementById("repo_files_panel");
      if (!panel) return;

      if (panel.dataset.initialized === "1") return;
      panel.dataset.initialized = "1";

      const repoId = panel.dataset.repoId;

      const checkAll = document.getElementById("check_all");
      const hint = document.getElementById("bulk_hint");

      const bulkDeleteBtn = document.getElementById("bulk_delete");
      const bulkScanBtn   = document.getElementById("bulk_scan");

      const deleteIdsBox  = document.getElementById("bulk_delete_file_ids");
      const deleteTrigger = document.getElementById("bulk_delete_trigger");

      const scanIdsBox    = document.getElementById("bulk_scan_file_ids");
      const scanTrigger   = document.getElementById("bulk_scan_trigger");

      const searchInput   = document.getElementById("path_filter_input");

      const checks = () => Array.from(document.querySelectorAll('input[data-file-check="1"]'));

      function selectedIds() {
        return checks().filter(x => x.checked).map(x => x.value);
      }

      // Scan always enabled; Delete requires selection.
      function setButtonsEnabled() {
        const count = selectedIds().length;
        if (bulkScanBtn) bulkScanBtn.disabled = false;
        if (bulkDeleteBtn) bulkDeleteBtn.disabled = (count === 0);
      }

      function updateHintAndButtons() {
        const count = selectedIds().length;
        if (hint) hint.textContent = count > 0 ? `Selected: ${count}` : "200/page";
        setButtonsEnabled();
      }

      function syncCheckAllState() {
        if (!checkAll) return;
        const all = checks();
        checkAll.checked = (all.length > 0 && all.every(x => x.checked));
      }

      function fillHiddenIds(container, ids) {
        if (!container) return;
        container.innerHTML = "";
        ids.forEach(id => {
          const input = document.createElement("input");
          input.type = "hidden";
          input.name = "file_ids[]";
          input.value = id;
          container.appendChild(input);
        });
      }

      function setScanConfirmMessage(idsCount) {
        if (!scanTrigger) return;

        const msgEmpty = panel.dataset.scanHintEmpty || "";
        const msgAll   = panel.dataset.scanHintAll || "";

        // Per requirement:
        // - ids empty => confirm_message_html = @scan_hint_message
        // - ids non-empty => confirm_message_html = @scan_all_hint
        const useMsg = (idsCount === 0 ? msgEmpty : msgAll);

        if (useMsg.length > 0) {
          scanTrigger.dataset.confirmMessageHtml = useMsg;
        }
      }

      // Select All
      if (checkAll) {
        checkAll.addEventListener("change", () => {
          checks().forEach(c => { c.checked = checkAll.checked; });
          updateHintAndButtons();
        });
      }

      // Single checkbox toggle
      panel.addEventListener("change", (e) => {
        if (e.target && e.target.matches && e.target.matches('input[data-file-check="1"]')) {
          syncCheckAllState();
          updateHintAndButtons();
        }
      });

      // Init
      updateHintAndButtons();

      // Delete: unchanged behavior (must have selection)
      if (bulkDeleteBtn) {
        bulkDeleteBtn.addEventListener("click", () => {
          const ids = selectedIds();
          if (ids.length === 0) return;

          fillHiddenIds(deleteIdsBox, ids);

          if (!deleteTrigger) {
            console.warn("[repo_files] bulk_delete_trigger not found");
            return;
          }
          deleteTrigger.click();
        });
      }

      // Scan: can run with empty selection; file_ids[] becomes empty (no hidden inputs added)
      if (bulkScanBtn) {
        bulkScanBtn.addEventListener("click", () => {
          const ids = selectedIds();

          // Always fill (empty => clears container => controller receives no file_ids[] => treat as [])
          fillHiddenIds(scanIdsBox, ids);

          if (!scanTrigger) {
            console.warn("[repo_files] bulk_scan_trigger not found");
            return;
          }

          setScanConfirmMessage(ids.length);
          scanTrigger.click();
        });
      }

      // Live search
      if (searchInput) {
        let timer = null;

        function runSearch() {
          const value = (searchInput.value || "").trim();
          const params = new URLSearchParams();

          if (repoId) params.set("repository_id", repoId);
          if (value.length > 0) params.set("path_filter", value);

          const url = `${window.location.pathname}?${params.toString()}`;
          window.location.assign(url);
        }

        searchInput.addEventListener("input", () => {
          if (timer) clearTimeout(timer);
          timer = setTimeout(runSearch, 250);
        });
      }
    }

    document.addEventListener("turbo:load", initRepoFilesPage);
    document.addEventListener("DOMContentLoaded", initRepoFilesPage);
  })();